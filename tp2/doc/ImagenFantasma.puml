@startditaa Imagen Fantasma

En memoria partimos cargando el pixel en ii,jj , el digito menos significativo esta a la izquierda

+----+----+----+----+----+----+----+----+
| b0 | g0 | r0 | a0 | b1 | g1 | r1 | a1 | [uint8]
+----+----+----+----+----+----+----+----+


Usando pmovzxbd en un registro xmm 


+----+----+----+----+
| b0 | g0 | r0 | a0 | [int32]
+----+----+----+----+


Usando CVTDQ2PS pasamos a float32

+----+----+----+----+
| b0 | g0 | r0 | a0 | [float32]
+----+----+----+----+

Multiplicamos por la constante 

+----+----+----+----+
| 1  | 2  | 1  |  0 | [float32]
+----+----+----+----+

Obtenemos

+-------+--------+--------+--------+
| b0 * 1| g0 * 2 | r0 * 1 | a0 * 0 | [float32]
+-------+--------+--------+--------+

Realizamos una suma horizontal con haddps

+-----------------+-----------------+-----------------+-----------------+
| b0 * 1 + g0 * 2 | r0 * 1 + a0 * 0 | b0 * 1 + g0 * 2 | r0 * 1 + a0 * 0 | [float32] 
+-----------------+-----------------+-----------------+-----------------+

Luego otra suma horizontal mas con haddps

+----------------------------------+----------------------------------+----------------------------------+----------------------------------+
| b0 * 1 + g0 * 2+ r0 * 1 + a0 * 0 | b0 * 1 + g0 * 2+ r0 * 1 + a0 * 0 | b0 * 1 + g0 * 2+ r0 * 1 + a0 * 0 | b0 * 1 + g0 * 2+ r0 * 1 + a0 * 0 | [float32] 
+----------------------------------+----------------------------------+----------------------------------+----------------------------------+

Realizamos una division  por la constante 8,8,8,1 con divps

+----+----+----+----+
| 8  | 8  | 8  |  1 | [float32]
+----+----+----+----+

Obteniendo

+--------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+
| (b0 * 1 + g0 * 2+ r0 * 1 + a0 * 0)/8 | (b0 * 1 + g0 * 2+ r0 * 1 + a0 * 0)/8 | (b0 * 1 + g0 * 2+ r0 * 1 + a0 * 0)/8 | (b0 * 1 + g0 * 2+ r0 * 1 + a0 * 0)/2 | [float32] 
+--------------------------------------+--------------------------------------+--------------------------------------+--------------------------------------+

Que en resumen es 

+-----+-----+-----+----+
| b/8 | b/8 | b/8 |  b | [float32]
+-----+-----+-----+----+

Luego en otro registro cargamos src i,j usando pmovzxbd y CVTDQ2PS

+-----+------+-----+-----+
| sb0 | sg0  | sr0 | sa0 | [float32]
+-----+------+-----+-----+

Multiplicamos por la contante .9 .9 .9 1

+----+----+----+----+
| .9 | .9 | .9 | 1  | [float32]
+----+----+----+----+

Obtenemos

+----------+----------+----------+----------+
| sb0 * .9 | sg0 * .9 | sr0 * .9 | sa0 * 1  | [float32]
+----------+----------+----------+----------+

sumamos el b obtenido antes

+------------------+----------------+-----------------+-------------+
| sb0 * .9 + b/8 | sg0 * .9 + b/8 | sr0 * .9  + b/8 | sa0 * 1 + b | [float32]
+------------------+----------------+-----------------+-------------+

Luego cvttps2dq 

+------------------+----------------+-----------------+-------------+
| (sb0 * .9) + b/8 | sg0 * .9 + b/8 | sr0 * .9  + b/8 | sa0 * 1 + b | [int32]
+------------------+----------------+-----------------+-------------+

luego saturamos a unsigned word con packusdw

+------------------+----------------+-----------------+-------------+-----+--
| (sb0 * .9) + b/8 | sg0 * .9 + b/8 | sr0 * .9  + b/8 | sa0 * 1 + b | ... | [uint16]
+------------------+----------------+-----------------+-------------+-----+--

Luego saturamos a unsigned nute con packuswb

+------------------+----------------+-----------------+-------------+-----+--
| (sb0 * .9) + b/8 | sg0 * .9 + b/8 | sr0 * .9  + b/8 | sa0 * 1 + b | ... | [uint8]
+------------------+----------------+-----------------+-------------+-----+--

Esto ultimo es el resultado




@endditaa